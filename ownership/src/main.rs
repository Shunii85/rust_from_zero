use std::arch::x86_64;

fn main() {
    //////////////////////////////////////
    // ムーブセマンティクス (所有権の移動)

    // #[derive(Debug)]
    // 水分子の型
    // struct H2O {}
    // // 酸素分子の型
    // #[derive(Debug)]
    // struct O2 {}
    // // 水素分子の型
    // #[derive(Debug)]
    // struct H2 {}

    // 水素分子2つと酸素分子1つを消費 -> 水分子を2つ生成
    // fn burn(_h2_1: H2, _h2_2: H2, _o2: O2) -> (H2O, H2O) {
    //     (H2O {}, H2O {})
    // }

    // let h2_1 = H2 {};
    // let h2_2 = H2 {};
    // let o2 = O2 {};

    // ここでそれぞれの変数は消費される！もう後で使えない
    // let (h2o_1, h2o_2) = burn(h2_1, h2_2, o2);

    // ↓エラー
    // println!("{:?}, {:?}, {:?}", h2_1, h2_2, o2);

    // struct Coin {}

    // let a = Coin {};
    // aさんの金貨をbさんに渡す
    // let b = a;
    // 同様にbさんがcさんに渡す
    // let c = b;

    // aさんは金貨を他の人に渡したので、再度渡すことはできない。
    // コンパイルエラー
    // let d = a;

    ///////////////////////////////////////////

    // ライフタイム
    // 以下はエラー
    // let a;
    // {
    //     let b = 10;
    //     a = &b;
    // }
    // println!("{}", a);

    // 正常にコンパイル
    // let a;
    // {
    //     let b = 10;
    //     a = &b;

    // ここでaが参照されるのは最後なので、非字句ライフタイム (non-lexical lifetime)
    // の考え方では、aもbもここでライフタイムは終了と捉えられる。エラーなし
    //     println!("{}", a);
    // }

    // ライフタイム指定子
    // ライフタイムは型として定義される！
    // let a: i32 = 10;
    // let b: &i32 = &a;

    // どちらもジェネリクスでライフタイムを取る？
    // ライフタイムを取る関数
    // fn square<'a>(x: &'a i32) -> i32 {
    //     x * x
    // }

    // println!("square(b): {}", square(b));

    // 参照を持つ構造体
    // #[derive(Debug)]
    // struct Foo<'a> {
    //     x: &'a i32,
    // }

    // let foo1 = Foo { x: &a };
    // println!("{:?}", foo1);

    ////////////////////////////////////////////
    // サブタイピング

    // サブタイピングはライフタイムにのみ許されている！
    // サブタイピングとは、部分的型付けのことであり、
    // サブタイプをスーパータイプに型付けすることをサブタイピングと呼ぶ

    // fn add<'a>(x: &'a mut i32, y: &'a i32) {
    //     *x += *y;
    // }

    // xのライフタイム => 0 ~ 5行目
    // yのライフタイム => 2 ~ 4行目

    // xのライフタイム => yのライフタイム へとサブタイピングできる。
    // xのライフタイムはyのライフタイムを拡張したものと言い換えられる。

    // let mut x = 10; // 0行目
    // {
    // let y = 20; // 2行目
    // add(&mut x, &y);
    // } // 4行目
    // println!("{x}"); // 5行目

    /////////////////////////////////////////////
    // 借用

    // 借用はムーブセマンティクスではなく、コピーセマンティクスである
    // let a = 10;
    // let b = &a;
    // let c = b;

    // assert_eq!(b, c);

    // 構造体のフィールドを借用してコンパイルエラーが出る例
    // #[derive(Debug)]
    // struct XY {
    //     x: Vec<i32>,
    //     y: Vec<i32>,
    //     selector: bool,
    //     scaler: i32,
    // }

    // {
    //     let mut xy = XY {
    //         x: vec![1, 2, 3],
    //         y: vec![4, 5, 6],
    //         selector: true,
    //         scaler: 3,
    //     };

    //     let v = xy.get_vec();
    //     // ↑でフィールドの可変参照を返したいがために、↓でxyの可変参照するのは不可能
    //     xy.update(v); // `xy`は借用されているためコンパイルエラー

    //     println!("{:?}", xy);
    // }

    // impl XY {
    //     // `selector`の応じて、`x`か`y`を返す
    //     // &mut selfが可変参照でないと(&selfの場合)、そもそもself.x, self.yを可変参照することができない
    //     fn get_vec(&mut self) -> &mut [i32] {
    //         let XY { x, y, .. } = self;
    //         if self.selector { x } else { y }
    //     }

    //     /// `v`になんらかの定型処理を行う
    //     fn update(&mut self, v: &mut [i32]) {
    //         for elm in v.iter_mut() {
    //             *elm *= self.scaler;
    //         }
    //     }
    // }

    /////////////////////////////////////////////

    //
}
